# from collections import namedtuple
# import copy
# import itertools as it


# """
# There are two players, called Min and Max.
# States specify the board layout, player locations, and whose turn it is.
# Actions specify a cell to move the player piece to, and a cell to delete.
# """
# State = namedtuple('State', ['board', 'min_pos', 'max_pos', 'min_to_play'])

# """
# An action is a tuple ((x1, y1), (x2, y2)) where (x1, y1) is
# the cell the agent moves to, and (x2, y2) is the cell the agent
# chooses to remove from the board.
# """
# Action = namedtuple('Move', ['move', 'delete'])


# class Game:
#     """
#     Implements the Isolation game for arbitrary square board sizes.

#     The Min player starts in the top row and the Max player in the bottom.
#     For odd board sizes, players start in the middle column.
#     For even board sizes, they'll be offset in opposite directions, e.g.
#         1 1 - 1
#         1 1 1 1
#         1 1 1 1
#         1 + 1 1
#     for a board of size 4.
#     """
#     dim = None  # Board width/height
#     init_state = None  # Full initial game state

#     def __init__(self, dim=7):
#         assert(dim > 1)
#         self.dim = dim

#         # place the players at the start locations
#         offset = 0 if (dim % 2 == 1) else 1
#         min_x, min_y = (dim // 2, 0)
#         max_x, max_y = (dim // 2 - offset, dim - 1)

#         # populate the board
#         board = [[1 for _ in range(dim)] for _ in range(dim)]
#         board[min_y][min_x] = 0
#         board[max_y][max_x] = 0

#         self.init_state = State(
#             board=board,
#             min_pos=(min_x, min_y),
#             max_pos=(max_x, max_y),
#             min_to_play=True
#         )

#     def set_init_state(self, state):
#         self.dim = len(state.board)
#         self.init_state = state

#     def set_init_state(self, state):
#         self.dim = len(state.board)
#         self.init_state = state

#     def __moveable_to(self, cell, state):
#         """
#         Returns whether it's legal for the current player to move to `cell`
#         """
#         x, y = cell
#         return (
#             x < self.dim and
#             y < self.dim and
#             x >= 0 and
#             y >= 0 and
#             state.board[y][x] == 1 and
#             (x, y) != state.min_pos and
#             (x, y) != state.max_pos
#         )

#     def get_actions(self, state):
#         """
#         Return all possible actions for the current player from `state`.
#         """

#         # player's current position
#         (px, py) = state.min_pos if state.min_to_play else state.max_pos
#         # opponent's current position
#         (ox, oy) = state.max_pos if state.min_to_play else state.min_pos

#         # all the possible cells the player could move to
#         legal_dests = [
#             (px + x, py + y) for (x, y) in it.product([0, -1, 1], repeat=2)
#             if (
#                 (x, y) != (0, 0) and  # player can't stay still
#                 self.__moveable_to((px + x, py + y), state)
#             )
#         ]

#         # all the possible cells the player could remove after moving
#         legal_removals = [
#             (x, y) for (x, y) in it.product(range(0, self.dim), repeat=2)
#             if state.board[y][x] == 1 and (x, y) != (ox, oy)
#         ]

#         legal_combos = [
#             Action(move=dest, delete=rem)
#             for dest in legal_dests for rem in legal_removals
#             if dest != rem  # can't remove the cell you're about to go to
#         ]

#         return legal_combos

#     def apply_action(self, state, action):
#         """
#         Return the state generated by taking `action` from `state`
#         """
#         (mx, my), (dx, dy) = action

#         # Remove the deleted cell from the board
#         new_board = copy.deepcopy(state.board)
#         new_board[dy][dx] = 0

#         # Relocate whichever player moved
#         new_min_pos = state.min_pos if not state.min_to_play else (mx, my)
#         new_max_pos = state.max_pos if state.min_to_play else (mx, my)

#         return State(
#             board=new_board,
#             min_pos=new_min_pos,
#             max_pos=new_max_pos,
#             min_to_play=not state.min_to_play
#         )

#     def utility(self, state):
#         """
#         Assuming `state` is terminal, return its utility.
#         Note that this returns a single utility for the whole game,
#         not the utility to a particular player.
#         """
#         assert(self.is_terminal(state))
#         return 1 if state.min_to_play else -1

#     def is_terminal(self, state):
#         # If the current player has no moves, we're in a terminal state
#         return len(self.get_actions(state)) == 0

#     def show(self, state):
#         """
#         Print out a nice image of the game state
#         """
#         board = [[str(cell) for cell in row] for row in state.board]
#         max_x, max_y = state.max_pos
#         min_x, min_y = state.min_pos
#         board[max_y][max_x] = '+'
#         board[min_y][min_x] = '-'

#         print("GAME STATE:")
#         print("========================")
#         print("Min to play") if state.min_to_play else print("Max to play")
#         for row in board:
#             for cell in row:
#                 print(cell, ' ', end='')
#             print()
#         print()

#     def play(self, min, max, verbose=True):
#         """
#         Play a game from start to finish between the agents `min` and `max`
#         By default, game states will be printed.
#         Call this with verbose=False to disable printing.
#         """
#         cur_state = self.init_state
#         num_moves = 0
#         while True:
#             for player in [min, max]:
#                 if verbose:
#                     self.show(cur_state)

#                 if self.is_terminal(cur_state):
#                     print("SUMMARY:")
#                     print("========================")
#                     print("Final utility:", self.utility(cur_state))
#                     print("Duration:", num_moves, "moves")
#                     return self.utility(cur_state), num_moves

#                 action = player.select_action(self, cur_state)
#                 cur_state = self.apply_action(cur_state, action)
#                 num_moves += 1

"""
Isolation Game v2
"""

from collections import namedtuple
import copy
import itertools as it


"""
There are two players, called Min and Max.
States specify the board layout, player locations, and whose turn it is.
Actions specify a cell to move the player piece to, and a cell to delete.
"""
State = namedtuple('State', ['board', 'min_pos', 'max_pos', 'min_to_play'])

"""
An action is a tuple ((x1, y1), (x2, y2)) where (x1, y1) is
the cell the agent moves to, and (x2, y2) is the cell the agent
chooses to remove from the board.
"""
Action = namedtuple('Move', ['move', 'delete'])


class Game:
    """
    Implements the Isolation game for arbitrary square board sizes.

    The Min player starts in the top row and the Max player in the bottom.
    For odd board sizes, players start in the middle column.
    For even board sizes, they'll be offset in opposite directions, e.g.
        1 1 - 1
        1 1 1 1
        1 1 1 1
        1 + 1 1
    for a board of size 4.
    """
    dim = None  # Board width/height
    init_state = None  # Full initial game state

    def __init__(self, dim=7):
        assert(dim > 1)
        self.dim = dim

        # place the players at the start locations
        offset = 0 if (dim % 2 == 1) else 1
        min_x, min_y = (dim // 2, 0)
        max_x, max_y = (dim // 2 - offset, dim - 1)

        # populate the board
        board = [[1 for _ in range(dim)] for _ in range(dim)]
        board[min_y][min_x] = 0
        board[max_y][max_x] = 0

        self.init_state = State(
            board=board,
            min_pos=(min_x, min_y),
            max_pos=(max_x, max_y),
            min_to_play=True
        )

    def set_init_state(self, state):
        self.dim = len(state.board)
        self.init_state = state

    def __moveable_to(self, cell, state):
        """
        Returns whether it's legal for the current player to move to `cell`
        """
        x, y = cell
        return (
            x < self.dim and
            y < self.dim and
            x >= 0 and
            y >= 0 and
            state.board[y][x] == 1 and
            (x, y) != state.min_pos and
            (x, y) != state.max_pos
        )

    def get_actions(self, state):
        """
        Return all possible actions for the current player from `state`.
        """

        # player's current position
        (px, py) = state.min_pos if state.min_to_play else state.max_pos
        # opponent's current position
        (ox, oy) = state.max_pos if state.min_to_play else state.min_pos

        # all the possible cells the player could move to
        legal_dests = [
            (px + x, py + y) for (x, y) in it.product([0, -1, 1], repeat=2)
            if (
                (x, y) != (0, 0) and  # player can't stay still
                self.__moveable_to((px + x, py + y), state)
            )
        ]

        # all the possible cells the player could remove after moving
        legal_removals = [
            (x, y) for (x, y) in it.product(range(0, self.dim), repeat=2)
            if state.board[y][x] == 1 and (x, y) != (ox, oy)
        ]

        legal_combos = [
            Action(move=dest, delete=rem)
            for dest in legal_dests for rem in legal_removals
            if dest != rem  # can't remove the cell you're about to go to
        ]

        return legal_combos

    def apply_action(self, state, action):
        """
        Return the state generated by taking `action` from `state`
        """
        (mx, my), (dx, dy) = action

        # Remove the deleted cell from the board
        new_board = copy.deepcopy(state.board)
        new_board[dy][dx] = 0

        # Relocate whichever player moved
        new_min_pos = state.min_pos if not state.min_to_play else (mx, my)
        new_max_pos = state.max_pos if state.min_to_play else (mx, my)

        return State(
            board=new_board,
            min_pos=new_min_pos,
            max_pos=new_max_pos,
            min_to_play=not state.min_to_play
        )

    def utility(self, state):
        """
        Assuming `state` is terminal, return its utility.
        Note that this returns a single utility for the whole game,
        not the utility to a particular player.
        """
        assert(self.is_terminal(state))
        return 1 if state.min_to_play else -1

    def is_terminal(self, state):
        # If the current player has no moves, we're in a terminal state
        return len(self.get_actions(state)) == 0

    def show(self, state):
        """
        Print out a nice image of the game state
        """
        board = [[str(cell) for cell in row] for row in state.board]
        max_x, max_y = state.max_pos
        min_x, min_y = state.min_pos
        board[max_y][max_x] = '+'
        board[min_y][min_x] = '-'

        print("GAME STATE:")
        print("========================")
        print("Min to play") if state.min_to_play else print("Max to play")
        for row in board:
            for cell in row:
                print(cell, ' ', end='')
            print()
        print()

    def play(self, min, max, verbose=True):
        """
        Play a game from start to finish between the agents `min` and `max`
        By default, game states will be printed.
        Call this with verbose=False to disable printing.
        """
        cur_state = self.init_state

        # Set the turn order
        (p1, p2) = (min, max) if cur_state.min_to_play else (max, min)

        num_moves = 0
        while True:
            for player in [p1, p2]:
                if verbose:
                    self.show(cur_state)

                if self.is_terminal(cur_state):
                    print("SUMMARY:")
                    print("========================")
                    print("Final utility:", self.utility(cur_state))
                    print("Duration:", num_moves, "moves")
                    return self.utility(cur_state), num_moves

                action = player.select_action(self, cur_state)
                cur_state = self.apply_action(cur_state, action)
                num_moves += 1